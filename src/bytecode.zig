const std = @import("std");
const testing = std.testing;

/// Opcode for the virtual machine
pub const Opcode = enum(u8) {
    // general ops
    load_integer = 0,
    load_string = 1,
    load_func = 2,
    load_const = 3, //deprecated
    load_true = 4,
    load_false = 5,
    load_nil = 6,
    load_void = 7,
    load_global = 8,
    bind_global = 9,
    load_local = 10,
    bind_local = 11,
    assign_global = 12,
    assign_local = 13,
    jump_false = 14,
    jump = 15,
    call = 16,
    @"return" = 17,
    return_value = 18,
    load_module = 19,
    iter_next = 20,

    make_array = 21,
    make_map = 22,
    make_iter = 23,
    make_range = 24,

    //bin op
    add = 25,
    sub = 26,
    mul = 27,
    div = 28,
    mod = 29,
    equal = 30,
    not_equal = 31,
    greater_than = 32,
    greater_than_equal = 33,
    less_than = 34,
    less_than_equal = 35,
    minus = 36,
    not = 37,
    bitwise_or = 38,
    bitwise_xor = 39,
    bitwise_and = 40,
    bitwise_not = 41,
    shift_left = 42,
    shift_right = 43,
    @"and" = 44,
    @"or" = 45,
    assign_add = 46,
    assign_sub = 47,
    assign_mul = 48,
    assign_div = 49,
    // same as equal but does not pop the lhs value for switch prong
    match = 50,

    // referencing
    get_by_index = 51,
    set_by_index = 52,

    /// specifically removes a value from the stack
    pop = 53,
};

/// Utility struct with helper functions to make it easier
/// to manage instructions
pub const Instructions = struct {
    list: std.ArrayList(Instruction),

    /// Creates a new instance of `Instructions`
    pub fn init(allocator: *std.mem.Allocator) Instructions {
        return .{ .list = std.ArrayList(Instruction).init(allocator) };
    }

    /// Return the amount of instructions
    pub fn len(self: Instructions) u32 {
        return @intCast(u32, self.list.items.len);
    }

    /// Appends a new `Instruction`
    pub fn append(self: *Instructions, inst: Instruction) !void {
        return self.list.append(inst);
    }

    /// Appends a new `Instruction` and returns the position of the instruction
    pub fn appendRetPos(self: *Instructions, inst: Instruction) !u32 {
        try self.list.append(inst);
        return self.len() - 1;
    }

    /// Can be used to check if last instruction is of given opcode
    pub fn lastIs(self: Instructions, op: Opcode) bool {
        const last = self.list.items[self.list.items.len - 1];
        return switch (last) {
            .op => |p| p == op,
            .ptr => |ptr| ptr.op == op,
            .integer => op == .load_integer,
            .string => op == .load_string,
            .function => op == .load_func,
        };
    }

    /// Replaces the ptr of an instruction, this is used for jumping instructions
    pub fn replacePtr(self: *Instructions, pos: u32, ptr: u32) void {
        self.list.items[pos].ptr.pos = ptr;
    }

    /// Replaces the opcode of the last instruction
    /// Asserts there's atleast 1 instruction saved
    pub fn replaceLastOp(self: *Instructions, op: Opcode) void {
        self.list.items[self.len() - 1].op = op;
    }

    /// Pops the last instruction
    pub fn pop(self: *Instructions) void {
        _ = self.list.popOrNull();
    }

    /// Frees all `Instructions` memory
    pub fn deinit(self: Instructions) void {
        self.list.deinit();
    }
};

/// Instruction generated by the compiler
/// Each instruction is encoded using little endian
pub const Instruction = union(Type) {
    op: Opcode,
    ptr: struct {
        op: Opcode,
        pos: u32,
    },
    integer: u64,
    string: []const u8,
    function: struct {
        locals: u32,
        arg_len: u8,
        entry: u32,
    },

    const Type = enum {
        op, ptr, integer, string, function
    };

    /// Returns the Opcode of the Instruction
    pub fn getOp(self: Instruction) Opcode {
        return switch (self) {
            .op => self.op,
            .ptr => |ptr| ptr.op,
            .integer => .load_integer,
            .string => .load_string,
            .function => .load_func,
        };
    }

    /// Generates a single opcode
    pub fn gen(op: Opcode) Instruction {
        return .{ .op = op };
    }

    /// Generates a `ptr` instruction
    pub fn genPtr(op: Opcode, ptr: u32) Instruction {
        return .{ .ptr = .{ .op = op, .pos = ptr } };
    }

    /// Generates an `integer` instruction
    pub fn genInteger(value: u64) Instruction {
        return .{ .integer = value };
    }

    /// Generates a `string` instruction
    pub fn genString(value: []const u8) Instruction {
        return .{ .string = value };
    }

    /// Generates a `function` Instruction
    pub fn genFunction(locals: usize, arg_len: usize, entry_point: u32) Instruction {
        return .{
            .function = .{
                .locals = @intCast(u32, locals),
                .arg_len = @intCast(u8, arg_len),
                .entry = entry_point,
            },
        };
    }
};

/// Byte code writer that encodes by little endian.
pub const Encoder = struct {
    /// Encodes the instructions and returns the encoded bytecode for in-memory usage
    /// Memory is owned by the caller
    pub fn encode(allocator: *std.mem.Allocator, instructions: []const Instruction) ![]const u8 {
        var code = std.ArrayList(u8).init(allocator);
        for (instructions) |inst| {
            try emitInstruction(inst, code.writer());
        }
        return code.toOwnedSlice();
    }

    /// Encodes the instructions and writes it to the input stream
    pub fn writeToStream(writer: anytype, instructions: []const Instruction) !void {
        for (instructions) |inst| {
            try emitInstruction(inst, writer);
        }
    }

    fn emitInstruction(inst: Instruction, writer: anytype) !void {
        switch (inst) {
            .op => |op| try emitOp(writer, op),
            .ptr => |ptr| try emitPtr(writer, ptr.op, ptr.pos),
            .integer => |int| try emitInteger(writer, int),
            .string => |string| try emitString(writer, string),
            .function => |func| try emitFunc(writer, .{
                .locals = func.locals,
                .arg_len = func.arg_len,
                .entry = func.entry,
            }),
        }
    }

    /// Emits a single opcode. This i
    fn emitOp(writer: anytype, op: Opcode) !void {
        var buffer: [1]u8 = undefined;
        std.mem.writeIntLittle(u8, &buffer, @enumToInt(op));
        return writer.writeAll(&buffer);
    }

    /// Emits an opcode and a ptr it points to. This could be a constant, array length, etc
    fn emitPtr(writer: anytype, op: Opcode, ptr: u32) !void {
        var buffer: [4]u8 = undefined;
        std.mem.writeIntLittle(u32, &buffer, ptr);

        try emitOp(writer, op);
        return writer.writeAll(&buffer);
    }

    /// Emits a load_integer opcode followed by the bytes representing the integer's value
    fn emitInteger(writer: anytype, value: u64) !void {
        var buffer: [8]u8 = undefined;
        std.mem.writeIntLittle(u64, &buffer, value);

        try emitOp(writer, .load_integer);
        return writer.writeAll(&buffer);
    }

    /// Emits a load_string opcode followed the the length of the string encoded as u16.
    /// Finalized by writing the value of the string
    /// The max length of the string is 65536.
    fn emitString(writer: anytype, value: []const u8) !void {
        var buffer: [2]u8 = undefined;
        std.mem.writeIntLittle(u16, &buffer, @intCast(u16, value.len));

        try emitOp(writer, .load_string);
        try writer.writeAll(&buffer);
        return writer.writeAll(value);
    }

    /// Emits a `load_func` opcode where the struct is encoded as a byte slice
    fn emitFunc(
        writer: anytype,
        func: struct {
            locals: u32,
            arg_len: u8,
            entry: u32,
        },
    ) !void {
        try emitOp(writer, .load_func);
        return writer.writeAll(std.mem.asBytes(&func));
    }
};

test "Encoding of instructions" {
    var buffer: [255]u8 = undefined;
    const instructions = &[_]Instruction{
        .{ .op = .load_false },
        .{ .string = "Hi" },
        .{ .integer = 5 },
        .{ .ptr = .{ .op = .jump, .pos = 5 } },
    };
    var stream = std.io.fixedBufferStream(&buffer);
    const code = try Encoder.encode(std.testing.allocator, instructions);
    defer std.testing.allocator.free(code);
    try Encoder.writeToStream(stream.writer(), instructions);

    const load_false = "\x05";
    const load_string = "\x01\x02\x00Hi";
    const load_int = "\x00\x05\x00\x00\x00\x00\x00\x00\x00";
    const load_ptr = "\x0F\x05\x00\x00\x00";
    std.testing.expectEqualSlices(u8, load_false ++ load_string ++ load_int ++ load_ptr, code);
    std.testing.expectEqualSlices(u8, load_false ++ load_string ++ load_int ++ load_ptr, stream.getWritten());
}
