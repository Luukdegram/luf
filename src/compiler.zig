const std = @import("std");
const parser = @import("parser.zig");
const ast = @import("ast.zig");
const Allocator = std.mem.Allocator;
const testing = std.testing;
const errors = @import("error.zig");

usingnamespace @import("value.zig");
usingnamespace @import("bytecode.zig");

//! Contains the Compiler internals.
//! This compiles all AST nodes generated by the parser and turned into `ByteCode` instructions
//! Those instructions are than used by the vm to be executed.
//! Potentially, we could provide a different back-end to support
//! different use cases.

/// Compiles the source code into Luf's bytecode
pub fn compile(
    allocator: *Allocator,
    source: []const u8,
    _errors: *errors.Errors,
) (parser.Parser.Error || Compiler.Error)!Compiler.ByteCode {
    const tree = try parser.parse(allocator, source, _errors);
    defer tree.deinit();

    var root_scope = Compiler.Scope{
        .symbols = Compiler.SymbolTable.init(allocator),
        .id = .global,
        .allocator = allocator,
    };
    defer root_scope.symbols.deinit();

    var compiler = Compiler{
        .instructions = Instructions.init(allocator),
        .allocator = allocator,
        .scope = &root_scope,
        .errors = _errors,
        .modules = std.StringHashMap(*Compiler.Module).init(allocator),
        .module_states = std.ArrayList(std.heap.ArenaAllocator.State).init(allocator),
    };
    defer compiler.deinit();
    errdefer {
        for (compiler.instructions.list.items) |inst| {
            if (inst == .string)
                allocator.free(inst.string);
            if (inst == .function)
                if (inst.function.name) |name| allocator.free(name);
        }
    }

    // declare all identifiers first
    try compiler.forwardDeclareNodes(tree.nodes);

    for (tree.nodes) |node| {
        try compiler.compile(node);
    }

    return Compiler.ByteCode{
        .instructions = compiler.instructions.list.toOwnedSlice(),
        .allocator = allocator,
    };
}

/// Contains the memory and generated instructions
/// after calling Compile()
pub const Compiler = struct {
    /// The instruction set the compiler is building
    instructions: Instructions,
    /// Allocator used to allocate to the heap, call deinit() on compiler to free all memory
    allocator: *Allocator,
    /// Any errors generated by the compiler will be appended to `errors`
    errors: *errors.Errors,
    /// Imported modules and their global symboltable
    modules: std.StringHashMap(*Module),
    /// Arena states which will be freed once we finished compilation
    /// This ensures all Nodes that are imported from other files have a long enough
    /// lifetime to be used for typechecking imported functions/variables
    module_states: std.ArrayList(std.heap.ArenaAllocator.State),
    /// Globals counter, this is increased by 1 each time a global is defined
    /// This is increased by both global and module scope
    gc: u16 = 0,
    /// Current scope of the compilation, i.e. .loop
    scope: *Scope,

    /// Symbols known by the compiler
    const Symbol = struct {
        name: []const u8,
        /// Not mutable by default
        mutable: bool = false,
        /// Index of symbol table
        index: u16 = 0,
        /// The scope the symbol belongs to
        scope: Scope.Id,
        /// The `Ast.Node` that declared the symbol, used to retrieve the symbol's type
        node: ast.Node,
        /// Set to `true` if the symbol was created during forward declaration
        forward_declared: bool,
    };

    /// Module with its global symbols
    const Module = struct {
        /// symbols existing inside the module
        symbols: SymbolTable,
        /// used to determine if module still requires codegen
        compiled: bool,
    };

    /// Hashmap of `Symbol` where the key is the Symbol's name
    const SymbolTable = std.StringArrayHashMap(Symbol);

    /// Scope of the current state (function, global, etc)
    const Scope = struct {
        /// Symbols that exist within the current scope
        symbols: SymbolTable,
        /// Type of the Scope. i.e. Root, function, etc
        id: Tag,
        /// If not a global scope, the scope will own a parent
        parent: ?*Scope = null,
        /// used to create child scopes
        allocator: *Allocator,

        /// The type of the scope
        const Id = enum {
            global,
            function,
            loop,
            module,
        };

        /// Some `Scope` types can have a payload
        const Tag = union(Id) {
            global,
            module,
            function: *const ast.Node.FunctionLiteral,
            loop: struct {
                start: u32,
                breaks: std.ArrayList(u32),
            },
        };

        /// Creates a new `Scope` from the current Scope.
        /// The new Scope will have its parent set to the current Scope
        fn fork(self: *Scope, id: Scope.Id) !*Scope {
            const new_scope = try self.allocator.create(Scope);
            new_scope.* = .{
                .symbols = SymbolTable.init(self.allocator),
                .id = switch (id) {
                    .global => .{ .global = {} },
                    .module => .{ .module = {} },
                    .function => .{ .function = undefined },
                    .loop => .{ .loop = .{ .start = 0, .breaks = std.ArrayList(u32).init(self.allocator) } },
                },
                .parent = self,
                .allocator = self.allocator,
            };
            return new_scope;
        }

        /// Defines a new symbol and saves it in the symbol table
        /// Returns an error if Symbol already exists
        fn define(self: *Scope, name: []const u8, mutable: bool, node: ast.Node, forward_declared: bool, index: ?u16) !?Symbol {
            if (self.symbols.get(name)) |_| return null;

            const new_index = index orelse @intCast(u16, self.symbols.items().len);

            var symbol = Symbol{
                .name = name,
                .mutable = mutable,
                .index = new_index,
                .scope = self.id,
                .node = node,
                .forward_declared = forward_declared,
            };
            try self.symbols.put(name, symbol);
            return symbol;
        }

        /// Retrieves a `Symbol` from the Scopes symbol table, returns null if not found
        fn resolve(self: *const Scope, name: []const u8) ?Symbol {
            return self.symbols.get(name);
        }

        /// Cleans up the memory of the `Scope`
        fn deinit(self: *Scope) void {
            if (self.id == .loop) self.id.loop.breaks.deinit();
            self.symbols.deinit();
            self.allocator.destroy(self);
        }
    };

    /// Compiler errorset
    pub const Error = error{ CompilerError, OutOfMemory };

    /// Generated bytecode by the `Compiler`
    pub const ByteCode = struct {
        instructions: []const Instruction,
        allocator: *Allocator,

        /// Encodes instructions to bytecode
        /// memory has to be freed by the caller
        pub fn encode(self: ByteCode) []const u8 {
            return Encoder.encode(self.allocator, self.instructions);
        }

        /// Encodes the instructions and emits to a writer stream
        pub fn encodeToStream(self: ByteCode, writer: anytype) !void {
            return Encoder.writeToStream(writer, self.instructions);
        }

        /// Frees all memory generated by the compiler
        pub fn deinit(self: *ByteCode) void {
            for (self.instructions) |i| {
                if (i == .string) self.allocator.free(i.string);
                if (i == .function) if (i.function.name) |name| self.allocator.free(name);
            }
            self.allocator.free(self.instructions);
            self.* = undefined;
        }
    };

    /// Frees up any memory allocated by the compiler
    fn deinit(self: *Compiler) void {
        var it = self.modules.iterator();
        while (it.next()) |mod| {
            mod.value.symbols.deinit();
            self.allocator.destroy(mod.value);
        }
        self.modules.deinit();
        self.exitScope();
        self.instructions.deinit();
        for (self.module_states.items) |state| {
            state.promote(self.allocator).deinit();
        }
        self.module_states.deinit();
        self.* = undefined;
    }

    /// Returns `Error.CompilerError` and appends an error message to the `errors` list.
    fn fail(self: *Compiler, comptime msg: []const u8, index: usize, args: anytype) Error {
        try self.errors.add(msg, index, .err, args);
        return Error.CompilerError;
    }

    /// Emits a new `Instruction`
    fn emit(self: *Compiler, instruction: Instruction) !void {
        return self.instructions.append(instruction);
    }

    /// Emites a new `Instruction` and returns its position
    fn emitReturnPos(self: *Compiler, instruction: Instruction) !u32 {
        return self.instructions.appendRetPos(instruction);
    }

    /// Removes the last instruction
    fn removeLastInst(self: *Compiler) void {
        _ = self.instructions.pop();
    }

    /// Sets the current `Scope` to its parent's scope and cleans up the closing scope's memory
    fn exitScope(self: *Compiler) void {
        if (self.scope.id == .global) return; // can't escape the global scope
        if (self.scope.parent) |parent| {
            const old = self.scope;
            self.scope = parent;
            old.deinit();
        }
    }

    /// Creates a new Scope with the given Id, then sets the new scope as the current
    fn createScope(self: *Compiler, id: Scope.Id) !void {
        self.scope = try self.scope.fork(id);
    }

    /// Recursively looks for the scope with the given Tag
    fn findScope(self: *Compiler, scope: *const Scope, tag: Scope.Id) ?*const Scope {
        if (scope.id == tag) return scope;
        return if (self.scope.parent) |parent| self.findScope(parent, tag) else null;
    }

    /// Attempts to resolve a symbol from the symbol table
    /// If not found, will attempt to resolve it from a parent scope
    fn resolveSymbol(self: *Compiler, scope: *const Scope, name: []const u8) ?Symbol {
        return if (scope.resolve(name)) |symbol|
            symbol
        else if (scope.id != .global and scope.parent != null)
            self.resolveSymbol(scope.parent.?, name)
        else
            null;
    }

    /// Defines a new symbol in the current scope
    fn defineSymbol(self: *Compiler, name: []const u8, mutable: bool, node: ast.Node, forward_declared: bool) !?Symbol {
        const index: ?u16 = if (self.scope.id == .global or self.scope.id == .module) self.gc else null;
        if (try self.scope.define(name, mutable, node, forward_declared, index)) |symbol| {
            self.gc += 1;
            return symbol;
        } else return null;
    }

    /// Returns a Luf `Type` based on the given node
    fn resolveType(self: *Compiler, node: ast.Node) !Value.Type {
        if (node.getType()) |t| return t;

        return switch (node) {
            .identifier => |id| {
                const symbol = self.resolveSymbol(self.scope, id.value) orelse
                    return self.fail("'{}' is undefined", id.token.start, .{id.value});

                return self.resolveType(symbol.node);
            },
            .infix => |inf| return self.resolveType(inf.left),
            .declaration => |decl| {
                if (decl.type_def) |td| return td.getType().?;

                return self.resolveType(decl.value);
            },
            .index => |index| return self.resolveType(index.left),
            .call_expression => |cal| return self.resolveType(cal.function),
            else => std.debug.panic("TODO, implement type resolving for type: {}\n", .{node}),
        };
    }

    /// Resolves the inner type of a node. i.e. this will return `Type.integer` for a list []int
    fn resolveScalarType(self: *Compiler, node: ast.Node) Error!Value.Type {
        if (node.getInnerType()) |i| return i;
        return switch (node) {
            .identifier => |id| {
                const symbol = self.resolveSymbol(
                    self.scope,
                    id.value,
                ) orelse return self.fail("'{}' is undefined", id.token.start, .{id.value});

                return self.resolveScalarType(symbol.node);
            },
            .infix => |inf| return self.resolveScalarType(inf.left),
            .declaration => |decl| {
                if (decl.type_def) |td| return td.getInnerType().?;

                return self.resolveScalarType(decl.value);
            },
            .index => |index| {
                const temp_type = try self.resolveScalarType(index.left);
                if (temp_type == .module) {
                    const function_name = index.index.string_lit.value;
                    const symbol = self.resolveSymbol(self.scope, index.left.identifier.value) orelse
                        return self.fail(
                        "'{}' is undefined",
                        index.left.tokenPos(),
                        .{index.left.identifier.value},
                    );

                    const mod: *Module = self.modules.get(symbol.node.declaration.value.import.value.string_lit.value).?;

                    const function_symbol: Symbol = mod.symbols.get(function_name) orelse
                        return self.fail("Module does not contain function '{}'", index.index.tokenPos(), .{function_name});

                    return self.resolveScalarType(function_symbol.node);
                }

                return self.resolveScalarType(index.left);
            },
            .call_expression => |cal| return self.resolveScalarType(cal.function),
            else => std.debug.panic("TODO, implement scalar type resolving for type: {}\n", .{node}),
        };
    }

    /// Retrieves all symbols for Nodes of type declaration
    fn forwardDeclareNodes(self: *Compiler, nodes: []const ast.Node) !void {
        for (nodes) |node| {
            if (node != .declaration) continue;
            const decl = node.declaration;

            if (decl.value == .import) {
                try self.forwardDeclareImport(decl.value.import);
                continue;
            } else if (decl.value != .func_lit) continue;

            const symbol = (try self.defineSymbol(decl.name.identifier.value, decl.mutable, node, true)) orelse
                return self.fail("'{}' has already been declared", node.tokenPos(), .{decl.name.identifier.value});
        }
        for (self.scope.symbols.items()) |symbol| {
            try self.compile(symbol.value.node.declaration.value);
            try self.emit(Instruction.genPtr(.bind_global, symbol.value.index));
        }
    }

    /// Forward declares all functions from a module, so we can do type checking for imported
    /// functions.
    fn forwardDeclareImport(self: *Compiler, node: *const ast.Node.Import) !void {
        const file_name = node.value.string_lit.value;
        if (self.modules.contains(file_name)) return;
        if (!std.mem.endsWith(u8, file_name, ".luf")) return;

        const file = std.fs.cwd().openFile(file_name, .{}) catch
            return self.fail("Cannot open file with path '{}'", node.value.tokenPos(), .{file_name});
        defer file.close();

        const size = file.getEndPos() catch return self.fail("Unable to find file size", node.value.tokenPos(), .{});
        const source = file.reader().readAllAlloc(self.allocator, size) catch return self.fail(
            "Failed to read content of file with path '{}'",
            node.value.tokenPos(),
            .{file_name},
        );
        defer self.allocator.free(source);

        const tree = try parser.parse(self.allocator, source, self.errors);
        errdefer tree.deinit();

        const module = try self.allocator.create(Module);
        errdefer self.allocator.destroy(module);

        module.* = .{ .symbols = SymbolTable.init(self.allocator), .compiled = false };
        errdefer module.symbols.deinit();

        for (tree.nodes) |n| {
            if (n != .declaration or n.declaration.value != .func_lit) continue;

            const decl = n.declaration;
            const name = decl.name.identifier.value;

            if (module.symbols.contains(name))
                return self.fail(
                    "Identifier '{}' already exists",
                    n.declaration.name.tokenPos(),
                    .{name},
                );

            const symbol = Symbol{
                .name = name,
                .mutable = decl.mutable,
                .scope = .global,
                .node = n,
                .forward_declared = true,
                .index = self.gc,
            };
            defer self.gc += 1;

            try module.symbols.putNoClobber(name, symbol);
        }

        try self.modules.putNoClobber(file_name, module);
        try self.module_states.append(tree.arena);
    }

    /// Compiles the given node into Instructions
    fn compile(self: *Compiler, node: ast.Node) (Error || parser.Parser.Error)!void {
        switch (node) {
            .expression => |exp| {
                try self.compile(exp.value);
                try self.emit(Instruction.gen(.pop));
            },
            .block_statement => |block| {
                for (block.nodes) |bnode| try self.compile(bnode);

                if (self.instructions.lastIs(.pop))
                    self.removeLastInst()
                else if (!self.instructions.lastIs(.return_value))
                    try self.emit(Instruction.gen(.load_void));
            },
            .infix => |inf| {
                var lhs = try self.resolveType(inf.left);
                var rhs = try self.resolveType(inf.right);

                if (lhs == .list or lhs == .range or lhs == .function) lhs = try self.resolveScalarType(inf.left);
                if (rhs == .list or rhs == .range or rhs == .function) rhs = try self.resolveScalarType(inf.right);

                if (lhs != rhs)
                    return self.fail("Expected type {} but found type {}", inf.right.tokenPos(), .{ lhs, rhs });

                try self.compile(inf.left);
                try self.compile(inf.right);
                _ = try self.emit(Instruction.gen(switch (inf.operator) {
                    .add => .add,
                    .multiply => .mul,
                    .sub => .sub,
                    .divide => .div,
                    .less_than => .less_than,
                    .greater_than => .greater_than,
                    .equal => .equal,
                    .not_equal => .not_equal,
                    .mod => .mod,
                    .@"and" => .@"and",
                    .@"or" => .@"or",
                    .bitwise_xor => .bitwise_xor,
                    .bitwise_or => .bitwise_or,
                    .bitwise_and => .bitwise_and,
                    .not => .bitwise_not,
                    .shift_left => .shift_left,
                    .shift_right => .shift_right,
                    .assign_add => .assign_add,
                    .assign_sub => .assign_sub,
                    .assign_mul => .assign_mul,
                    .assign_div => .assign_div,
                    else => unreachable,
                }));
            },
            .prefix => |pfx| {
                try self.compile(pfx.right);
                _ = try self.emit(Instruction.gen(switch (pfx.operator) {
                    .minus => .minus,
                    .bang => .not,
                    .bitwise_not => .bitwise_not,
                }));
            },
            .boolean => |boolean| _ = try self.emit(Instruction.gen(if (boolean.value) .load_true else .load_false)),
            .int_lit => |int| {
                try self.emit(Instruction.genInteger(int.value));
            },
            .if_expression => |if_exp| {
                try self.compile(if_exp.condition);
                // false is last so put it bottom of the added stack
                const false_pos = try self.emitReturnPos(Instruction.genPtr(.jump_false, 0));

                // compile the true pong and place the emitted opcodes on the stack
                try self.compile(if_exp.true_pong);

                // Add a jump to the stack and return its position
                const jump_pos = try self.emitReturnPos(Instruction.genPtr(.jump, 0));

                // Point the position of the false jump to the current position
                self.instructions.replacePtr(false_pos, self.instructions.len());

                if (if_exp.false_pong) |pong|
                    try self.compile(pong)
                else
                    try self.emit(Instruction.gen(.load_void));

                // set the true jump to the current stack position
                self.instructions.replacePtr(jump_pos, self.instructions.len());
            },
            .declaration => |decl| {
                if (decl.type_def) |td| {
                    const explicit_type = try self.resolveType(td);
                    var rhs_type = try self.resolveType(decl.value);
                    // if function, get the return type of the function
                    if (rhs_type == .function or rhs_type == .module) rhs_type = try self.resolveScalarType(decl.value);

                    if (explicit_type != rhs_type)
                        return self.fail(
                            "Expected type {} but found type {}",
                            decl.value.tokenPos(),
                            .{ explicit_type, rhs_type },
                        );
                }

                if (self.resolveSymbol(self.scope, decl.name.identifier.value)) |*s| {
                    if (decl.value == .func_lit and s.forward_declared) {
                        s.forward_declared = false;
                        return;
                    } else
                        return self.fail(
                            "Identifier '{}' has already been declared",
                            decl.token.start,
                            .{decl.name.identifier.value},
                        );
                }
                const symbol = (try self.defineSymbol(decl.name.identifier.value, decl.mutable, node, false)).?;

                try self.compile(decl.value);

                const opcode: Opcode = if (symbol.scope == .global)
                    .bind_global
                else
                    .bind_local;

                try self.emit(Instruction.genPtr(opcode, symbol.index));
            },
            .identifier => |id| if (self.resolveSymbol(self.scope, id.value)) |symbol| {
                const opcode: Opcode = switch (symbol.scope) {
                    .global, .module => .load_global,
                    .function, .loop => .load_local,
                };
                try self.emit(Instruction.genPtr(opcode, symbol.index));
            } else return self.fail("Identifier '{}' is undefined", id.token.start, .{id.value}),
            .string_lit => |string| try self.emit(Instruction.genString(try self.allocator.dupe(u8, string.value))),
            .data_structure => |ds| {
                const inner_type = try self.resolveScalarType(node);

                // ds.value will only be null if it's specified as a type rather than an expression
                for (ds.value.?) |element, i| {
                    const el_type = try self.resolveScalarType(element);
                    if (inner_type != el_type)
                        return self.fail(
                            "Expected type {} but found type {} for element {}",
                            element.tokenPos(),
                            .{ inner_type, el_type, i },
                        );

                    try self.compile(element);
                }

                try self.emit(Instruction.genPtr(
                    if (ds.d_type == .array) .make_array else .make_map,
                    @intCast(u32, ds.value.?.len),
                ));
            },
            .map_pair => |pair| {
                try self.compile(pair.key);
                try self.compile(pair.value);
            },
            .index => |index| {
                if ((try self.resolveType(index.left)) == .module) {
                    const module_symol = self.resolveSymbol(self.scope, index.left.identifier.value).?;
                    const module_name = module_symol.node.declaration.value.import.value.string_lit.value;
                    if (self.modules.get(module_name)) |module| {
                        const func_name = index.index.string_lit.value;
                        var func: Symbol = module.symbols.get(func_name).?;

                        try self.emit(Instruction.genPtr(.load_global, func.index));
                    } else {
                        try self.compile(index.left);
                        try self.compile(index.index);
                        try self.emit(Instruction.gen(.get_by_index));
                    }
                } else {
                    try self.compile(index.left);
                    try self.compile(index.index);
                    try self.emit(Instruction.gen(.get_by_index));
                }
            },
            .func_lit => |function| {
                const jump_pos = try self.emitReturnPos(Instruction.genPtr(.jump, 0));
                try self.createScope(.function);
                self.scope.id.function = function;
                const inst_ptr = jump_pos + 1;

                for (function.params) |param| {
                    // function arguments are not mutable by default
                    _ = (try self.defineSymbol(param.func_arg.value, false, param, false)) orelse
                        return self.fail(
                        "Identifier '{}' has already been declared",
                        function.token.start,
                        .{param.func_arg.value},
                    );
                }

                try self.compile(function.body orelse return self.fail(
                    "Function body missing",
                    function.token.start,
                    .{},
                ));

                // if no return_value found, emit a regular return instruction
                if (!self.instructions.lastIs(.return_value)) try self.emit(Instruction.gen(.@"return"));

                const locals = self.scope.symbols.items().len;
                self.exitScope();

                const name: ?[]const u8 = if (function.name) |name|
                    try self.allocator.dupe(u8, name)
                else
                    null;
                errdefer if (name) |n| self.allocator.free(n);

                const last_pos = try self.emitReturnPos(Instruction.genFunction(name, locals, function.params.len, inst_ptr));
                self.instructions.replacePtr(jump_pos, last_pos);
            },
            .call_expression => |call| {
                const initial_function_type = try self.resolveType(call.function);
                // function is either builtin or defined on a type
                // for now this can only be checked at runtime as the compiler is unaware of builtins
                if (call.function == .index and initial_function_type != .module) {
                    for (call.arguments) |arg| {
                        try self.compile(arg);
                    }
                    try self.compile(call.function);
                } else {
                    //if it's an identifier, we first do a lookup to retrieve it's declaration node
                    //then return the function declaration. else we return the function itself
                    //in the case of an anonymous function
                    const function_node = if (call.function == .identifier and initial_function_type != .module) blk: {
                        const function = self.resolveSymbol(self.scope, call.function.identifier.value) orelse
                            return self.fail(
                            "Function '{}' is undefined",
                            call.function.tokenPos(),
                            .{call.function.identifier.value},
                        );
                        break :blk function.node.declaration.value.func_lit;
                    } else if (initial_function_type != .module)
                        call.function.func_lit
                    else blk: {
                        if (call.function == .index) {
                            // we handle module functions here
                            const function_name = call.function.index.index.string_lit.value;
                            const symbol = self.resolveSymbol(self.scope, call.function.index.left.identifier.value) orelse
                                return self.fail(
                                "Identifier '{}' does not exist",
                                call.function.index.left.tokenPos(),
                                .{call.function.index.left.identifier.value},
                            );

                            const mod = self.modules.get(symbol.node.declaration.value.import.value.string_lit.value).?;
                            const decl_symbol: Symbol = mod.symbols.get(function_name) orelse
                                return self.fail("Module does not contain function '{}'", call.function.tokenPos(), .{function_name});

                            break :blk decl_symbol.node.declaration.value.func_lit;
                        } else {
                            // not a module, so expect a library
                            for (call.arguments) |arg| {
                                try self.compile(arg);
                            }

                            try self.compile(call.function);

                            // actual function will be on top of stack, due to it being called by index
                            return self.emit(Instruction.genPtr(.call, @intCast(u32, 0)));
                        }
                    };

                    if (function_node.params.len != call.arguments.len)
                        return self.fail("Expected {} arguments, but found {}", call.token.start, .{
                            function_node.params.len,
                            call.arguments.len,
                        });

                    try self.compile(call.function);

                    for (call.arguments) |arg, i| {
                        const arg_type = try self.resolveType(arg);
                        const func_arg_type = try self.resolveType(function_node.params[i]);

                        if (arg_type != func_arg_type)
                            return self.fail(
                                "Expected type '{}' but found type '{}'",
                                arg.tokenPos(),
                                .{ func_arg_type, arg_type },
                            );
                        try self.compile(arg);
                    }

                    try self.emit(Instruction.genPtr(.call, @intCast(u32, call.arguments.len)));
                }
            },
            .@"return" => |ret| {
                const scope = self.findScope(self.scope, .function) orelse
                    return self.fail(
                    "Unexpected return statement. Return can only be done while inside a function body",
                    node.tokenPos(),
                    .{},
                );

                const func_ret_type = scope.id.function.ret_type.getType();
                var ret_type = try self.resolveType(ret.value);

                if (ret_type == .function) {
                    ret_type = try self.resolveScalarType(ret.value);
                }

                if (func_ret_type != ret_type)
                    return self.fail(
                        "Expected return type '{}' but found type '{}'",
                        ret.value.tokenPos(),
                        .{ func_ret_type, ret_type },
                    );

                try self.compile(ret.value);
                try self.emit(Instruction.gen(.return_value));
            },
            .while_loop => |loop| {
                try self.createScope(.loop);

                // beginning of while
                self.scope.id.loop.start = self.instructions.len();

                try self.compile(loop.condition);

                // jump position if condition equals false
                const false_jump = try self.emitReturnPos(Instruction.genPtr(.jump_false, 0));

                try self.compile(loop.block);

                const end = try self.emitReturnPos(Instruction.genPtr(.jump, self.scope.id.loop.start));

                // jump to end
                self.instructions.replacePtr(false_jump, end + 1);

                for (self.scope.id.loop.breaks.items) |pos| {
                    self.instructions.list.items[pos].ptr.pos = end + 1;
                }
                self.exitScope();
            },
            .for_loop => |loop| {
                try self.createScope(.loop);
                const iterator_type = try self.resolveType(loop.iter);

                if (iterator_type != .list and iterator_type != .range and iterator_type != .string) {
                    return self.fail(
                        "Expected a list, range or string, but found type '{}'",
                        loop.iter.tokenPos(),
                        .{iterator_type},
                    );
                }
                try self.compile(loop.iter);

                try self.emit(Instruction.genPtr(
                    .make_iter,
                    @as(u32, if (loop.index != null) 1 else 0),
                ));

                self.scope.id.loop.start = try self.emitReturnPos(Instruction.gen(.iter_next));

                // jump position if we reached the end of the iterator
                const end_jump = try self.emitReturnPos(Instruction.genPtr(.jump_false, 0));

                // parser already parses it as an identifier, no need to check here again
                const capture = (try self.defineSymbol(loop.capture.identifier.value, false, loop.iter, false)) orelse return self.fail(
                    "Capture identifier '{}' has already been declared",
                    loop.token.start,
                    .{loop.capture.identifier.value},
                );
                try self.emit(Instruction.genPtr(.assign_local, capture.index));

                // as above, parser ensures it's an identifier
                if (loop.index) |i| {
                    // loop is just a boolean, so create a new Node that represents the integer for the counter
                    const index_node = &ast.Node.ForLoop.index_node;
                    index_node.token = i.identifier.token;

                    const symbol = (try self.defineSymbol(i.identifier.value, false, ast.Node{ .int_lit = index_node }, false)) orelse
                        return self.fail("Identifier '{}' has already been declared", loop.token.start, .{i.identifier.value});

                    try self.emit(Instruction.genPtr(.assign_local, symbol.index));
                }

                try self.compile(loop.block);

                // pop last value from block
                try self.emit(Instruction.gen(.pop));

                // jump to start of loop to evaluate range
                try self.emit(Instruction.genPtr(.jump, self.scope.id.loop.start));

                // pop capture and index from stack
                const end = try self.emitReturnPos(Instruction.gen(.pop));
                if (loop.index) |_| {
                    try self.emit(Instruction.gen(.pop));
                }

                for (self.scope.id.loop.breaks.items) |pos| {
                    self.instructions.list.items[pos].ptr.pos = end;
                }

                // point the end jump to last op
                self.instructions.replacePtr(end_jump, end);

                self.exitScope();
            },
            .assignment => |asg| {
                if (asg.left == .identifier) {
                    const symbol = self.resolveSymbol(
                        self.scope,
                        asg.left.identifier.value,
                    ) orelse return self.fail(
                        "Identifier '{}' is undefined",
                        asg.token.start,
                        .{asg.left.identifier.value},
                    );

                    if (!symbol.mutable) return self.fail("Identifier '{}' is constant", asg.token.start, .{symbol.name});

                    const right_type = try self.resolveType(asg.right);
                    const left_type = try self.resolveType(symbol.node);
                    if (left_type != right_type)
                        return self.fail("Assignment expected type '{}' but found type '{}'", asg.token.start, .{
                            left_type,
                            right_type,
                        });

                    try self.compile(asg.right);

                    try self.emit(Instruction.genPtr(
                        if (symbol.scope == .global) .assign_global else .assign_local,
                        symbol.index,
                    ));
                } else if (asg.left == .index) {
                    const index = asg.left.index;

                    const lhs_type = try self.resolveScalarType(index.left);
                    const rhs_type = try self.resolveScalarType(asg.right);

                    if (lhs_type != rhs_type)
                        return self.fail("Expected type '{}' but found type '{}'", asg.right.tokenPos(), .{
                            lhs_type,
                            rhs_type,
                        });

                    try self.compile(index.left);
                    try self.compile(index.index);
                    try self.compile(asg.right);
                    try self.emit(Instruction.gen(.set_by_index));
                } else {
                    return self.fail("Expected an identifier on left hand side", asg.left.tokenPos(), .{});
                }
            },
            .nil => try self.emit(Instruction.gen(.load_nil)),
            .import => |imp| {
                // no need for resolveType, this is faster
                if (imp.value != .string_lit) return self.fail("Expected a string literal", imp.value.tokenPos(), .{});
                const file_name = imp.value.string_lit.value;
                if (std.mem.endsWith(u8, file_name, ".luf")) {
                    // forward declaration would have defined it, so we can be sure it exists
                    var mod: *Module = self.modules.get(file_name).?;
                    if (mod.compiled) {
                        try self.emit(Instruction.gen(.load_module));
                        return;
                    }
                    try self.createScope(.module);

                    const file = std.fs.cwd().openFile(file_name, .{}) catch
                        return self.fail("Could not open file at path '{}'", node.tokenPos(), .{file_name});
                    defer file.close();
                    const size = file.getEndPos() catch return self.fail("Could not determine file size", node.tokenPos(), .{});
                    const source = file.reader().readAllAlloc(self.allocator, size) catch
                        return self.fail("Could not read file", node.tokenPos(), .{});
                    defer self.allocator.free(source);
                    const tree = try parser.parse(self.allocator, source, self.errors);
                    defer tree.deinit();

                    for (mod.symbols.items()) |entry| {
                        const symbol: Symbol = entry.value;
                        _ = try self.scope.define(symbol.name, symbol.mutable, symbol.node, true, symbol.index);
                    }

                    // we can't do it in the loop above because all symbols need to be defined first so we
                    // can call functions from other functions
                    for (self.scope.symbols.items()) |entry| {
                        try self.compile(entry.value.node.declaration.value);
                        try self.emit(Instruction.genPtr(.bind_global, entry.value.index));
                    }

                    for (tree.nodes) |n| {
                        try self.compile(n);
                    }
                    mod.compiled = true;
                    self.exitScope();
                }

                try self.compile(imp.value);
                try self.emit(Instruction.gen(.load_module));
            },
            .@"break" => |br| {
                if (self.scope.id != .loop)
                    return self.fail(
                        "Breaks can only be used while inside a for or while loop",
                        br.token.start,
                        .{},
                    );

                const pos = try self.emitReturnPos(Instruction.genPtr(.jump, 0));
                try self.scope.id.loop.breaks.append(pos);
            },
            .@"continue" => |cont| {
                if (self.scope.id != .loop)
                    return self.fail(
                        "Continue can only be used while inside a for or while loop",
                        cont.token.start,
                        .{},
                    );
                try self.emit(Instruction.genPtr(.jump, self.scope.id.loop.start));
            },
            .range => |range| {
                const lhs_type = try self.resolveScalarType(range.left);
                const rhs_type = try self.resolveScalarType(range.right);

                if (lhs_type != .integer) return self.fail("Expected an integer but found type '{}'", range.left.tokenPos(), .{lhs_type});
                if (rhs_type != .integer) return self.fail("Expected an integer but found type '{}'", range.right.tokenPos(), .{rhs_type});

                try self.compile(range.left);
                try self.compile(range.right);
                try self.emit(Instruction.gen(.make_range));
            },
            .@"enum" => |enm| {
                for (enm.nodes) |n| {
                    if (n != .identifier)
                        return self.fail(
                            "Found an identifier but found type '{}' inside the Enum declaration",
                            enm.token.start,
                            .{try self.resolveType(n)},
                        );

                    try self.emit(Instruction.genString(try self.allocator.dupe(u8, n.identifier.value)));
                }

                try self.emit(Instruction.genPtr(.make_enum, @intCast(u32, enm.nodes.len)));
            },
            // currently, switches operate on runtime until static types are implemented
            .switch_statement => |sw| {
                try self.compile(sw.capture);
                const capture_type = try self.resolveType(sw.capture);
                if (capture_type != .integer and capture_type != .string)
                    return self.fail("Switches are only allowed for integers, enums and strings. Found type '{}'", sw.capture.tokenPos(), .{capture_type});

                for (sw.prongs) |p| {
                    try self.compile(p);
                }
                try self.emit(Instruction.gen(.pop));
            },
            .switch_prong => |prong| {
                const prong_type = try self.resolveType(prong.left);
                switch (prong_type) {
                    .integer, .string, .range => {},
                    else => return self.fail("Unpermitted type '{}' in switch case", prong.left.tokenPos(), .{prong_type}),
                }

                // compile lhs of prong
                try self.compile(prong.left);

                // match with capture, capture is not popped from stack until the end
                try self.emit(Instruction.gen(.match));

                const last_jump_false = try self.emitReturnPos(Instruction.genPtr(.jump_false, 0));
                try self.compile(prong.right);
                self.instructions.replacePtr(last_jump_false, self.instructions.len());
            },

            else => {}, //TypeDef and Comments are not compiled
        }
    }
};

test "Compile AST to bytecode" {
    const test_cases = .{
        .{
            .input = "1 + 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .add, .pop },
        },
        .{
            .input = "3 - 1",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .sub, .pop },
        },
        .{
            .input = "1 * 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .mul, .pop },
        },
        .{
            .input = "2 / 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .div, .pop },
        },
        .{
            .input = "true",
            .opcodes = &[_]Opcode{ .load_true, .pop },
        },
        .{
            .input = "1 > 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .greater_than, .pop },
        },
        .{
            .input = "1 < 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .less_than, .pop },
        },
        .{
            .input = "1 == 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .equal, .pop },
        },
        .{
            .input = "1 != 2",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .not_equal, .pop },
        },
        .{
            .input = "true == false",
            .opcodes = &[_]Opcode{ .load_true, .load_false, .equal, .pop },
        },
        .{
            .input = "-1",
            .opcodes = &[_]Opcode{ .load_integer, .minus, .pop },
        },
        .{
            .input = "!true",
            .opcodes = &[_]Opcode{ .load_true, .not, .pop },
        },
        .{
            .input = "if (true) { 5 } 10",
            .opcodes = &[_]Opcode{
                .load_true,
                .jump_false,
                .load_integer,
                .jump,
                .load_void,
                .pop,
                .load_integer,
                .pop,
            },
        },
        .{
            .input = "if (true) { 5 } else { 7 } 10",
            .opcodes = &[_]Opcode{
                .load_true,
                .jump_false,
                .load_integer,
                .jump,
                .load_integer,
                .pop,
                .load_integer,
                .pop,
            },
        },
        .{
            .input = "const x = \"foo\"",
            .opcodes = &[_]Opcode{ .load_string, .bind_global },
        },
        .{
            .input = "const x = []int{1, 2, 3}",
            .opcodes = &[_]Opcode{ .load_integer, .load_integer, .load_integer, .make_array, .bind_global },
        },
        .{
            .input = "const x = []int:int{1: 2, 2: 1, 5: 6}",
            .opcodes = &[_]Opcode{
                .load_integer,
                .load_integer,
                .load_integer,
                .load_integer,
                .load_integer,
                .load_integer,
                .make_map,
                .bind_global,
            },
        },
        .{
            .input = "[]int{1}[0]",
            .opcodes = &[_]Opcode{
                .load_integer,
                .make_array,
                .load_integer,
                .get_by_index,
                .pop,
            },
        },
        .{
            .input = "[]int:int{1: 10}[0]",
            .opcodes = &[_]Opcode{
                .load_integer,
                .load_integer,
                .make_map,
                .load_integer,
                .get_by_index,
                .pop,
            },
        },
        .{
            .input = "fn() void { 1 + 2 }",
            .opcodes = &[_]Opcode{
                .jump,
                .load_integer,
                .load_integer,
                .add,
                .@"return",
                .load_func,
                .pop,
            },
        },
        .{
            .input = "fn() void { }",
            .opcodes = &[_]Opcode{
                .jump,
                .load_void,
                .@"return",
                .load_func,
                .pop,
            },
        },
        .{
            .input = "fn() void { 1 }()",
            .opcodes = &[_]Opcode{
                .jump,
                .load_integer,
                .@"return",
                .load_func,
                .call,
                .pop,
            },
        },
        .{
            .input = "const x = fn() void { 1 } x()",
            .opcodes = &[_]Opcode{
                .jump,
                .load_integer,
                .@"return",
                .load_func,
                .bind_global,
                .load_global,
                .call,
                .pop,
            },
        },
        .{
            .input = "const x = 5 fn() int { return x }",
            .opcodes = &[_]Opcode{
                .load_integer,
                .bind_global,
                .jump,
                .load_global,
                .return_value,
                .load_func,
                .pop,
            },
        },
        .{
            .input = "fn() int { const x = 5 return x }",
            .opcodes = &[_]Opcode{
                .jump,
                .load_integer,
                .bind_local,
                .load_local,
                .return_value,
                .load_func,
                .pop,
            },
        },
        .{
            .input = "const func = fn(x: int) int { return x } func(5)",
            .opcodes = &[_]Opcode{
                .jump,
                .load_local,
                .return_value,
                .load_func,
                .bind_global,
                .load_global,
                .load_integer,
                .call,
                .pop,
            },
        },
        .{
            .input = "const x = \"string\".len",
            .opcodes = &[_]Opcode{
                .load_string,
                .load_string,
                .get_by_index,
                .bind_global,
            },
        },
        .{
            .input = "while (true) { 10 }",
            .opcodes = &[_]Opcode{
                .load_true,
                .jump_false,
                .load_integer,
                .jump,
                .pop,
                //.pop,
            },
        },
        .{
            .input = "mut x = 5 x = 6",
            .opcodes = &[_]Opcode{
                .load_integer,
                .bind_global,
                .load_integer,
                .assign_global,
                .pop,
            },
        },
        .{
            .input = "const imp = import(\"examples/to_import.luf\") const x:int = imp.sum(2, 5)",
            .opcodes = &[_]Opcode{},
        },
    };

    inline for (test_cases) |case| {
        var _errors = errors.Errors.init(testing.allocator);
        defer _errors.deinit();
        var code = compile(testing.allocator, case.input, &_errors) catch |err| {
            try _errors.write(case.input, std.io.getStdErr().writer());
            return err;
        };
        defer code.deinit();

        for (case.opcodes) |op, i| {
            //std.debug.print("Instr: {}\n", .{code.instructions[i]});
            testing.expectEqual(op, code.instructions[i].getOp());
        }
    }
}
